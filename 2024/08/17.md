## やったこと	
- 達人に学ぶDB設計 ~5章

## わかったこと
### 第一正規化を行う理由
第一正規化ではセルには1つの値（スカラ値）のみ許容するようにテーブルを構成します。各セルに対して複数の値を許容すると主キーによってレコードを特定することができないから。

### 第二正規化を行う理由
第二正規化では部分関数従属を排除します。部分関数従属を許容してしまうと部分関数従属している列に対して新しいレコードを追加したいが、従属していない主キーの要素の列の値が決まっていないとき、従属していない主キーの要素の列の値が決まらない限り、部分関数従属している列に対して新しいレコードを追加することができません。また、アプリケーション側で制御しない限り、部分従属している列とされている列で値の不整合が起きてしまう可能性があります。

### 第三正規化を行う理由
第三正規化では推移的関数従属を排除します。推移的関数従属を許容すると推移的関数従属している列の値だけを追加したいが、主キーの値が決まっていない場合にレコードを追加することができません。

### ボイスーコッド正規化を行う理由
非キーからキーへの関数従属があると、非キーの更新をする際に複数のレコードを更新する必要があることやきーからキーからある値が削除されると、非キーとキーへの関係が崩れてしまう可能性がある。ボイスーコッドだけではDBの整合性を保てない場合もあるのでその際はアプリケーション側で制御を行う。

### 第四正規化を行う理由
一つのテーブルにおいて、キーが複数の多値従属を持つ場合、特定のレコードを更新したい場合でも複数のレコードを更新する必要（冗長化）やすべての列の値が決まらないとレコードを挿入することができなくなってしまう。<br>
第二、三正規化の時点で弾かれることが大半ですが、正規化漏れや仕様変更に伴い第四正規化を行う場面はないわけではない。

### 第五正規化
第四正規化と同じように関連テーブルを作成します。AとBが関連エンティティの場合、AとBの関連テーブルを作成する、ここにBと関連するCが必要になった際にはBとCで関連テーブルを作成することになる。第四テーブルと同じようにこれ以前の正規化で排除されていることが考えられる。

## 正規化による整合性とパフォーマンスはトレードオフ
- 正規化は高次元まで行うことで整合性が高まる一方で、多くのテーブルを結合する必要があるのでI/Oの観点からパフォーマンスが低下する。パフォーマンスを優先する場合は、非正規化を行い第2,3正規化を崩すことにより、パフォーマンスを上げることができる。しかし、非正規化により加えた列には更新時に複数の更新をかける必要やその列に影響を与えるような処理を実行した際にはパッチを当てなければならないけないためコストがかかる。まさにあっちを立てればこっちが立たずといった具合なので、パフォーマンスと整合性のどちらを優先させるのかを判断することは難しい。
## 感じたこと
## 学習時間
10h
